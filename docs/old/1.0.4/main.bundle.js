(()=>{"use strict";var e={33:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.camera=void 0,t.camera="\nRay cameraGetRay(vec3 lookFrom, vec3 lookAt, vec3 vUp, float vFov) {\n    float aspectRatio = u_resolution.x / u_resolution.y;\n    float theta = vFov * PI / 180.0;\n    float h = tan(theta / 2.0);\n    float viewportHeight = 2.0 * h;\n    float viewportWidth = aspectRatio * viewportHeight;\n\n    vec3 w = normalize(lookFrom - lookAt);\n    vec3 u = normalize(cross(vUp, w));\n    vec3 v = cross(w, u);\n\n    vec3 horizontal = u * viewportWidth;\n    vec3 vertical = v * viewportHeight;\n    vec3 lowerLeftCorner = lookFrom - (horizontal / 2.0) - (vertical / 2.0) - w;\n\n    vec2 uv = (gl_FragCoord.xy + vec2(0, float(u_renderYOffset))) / (u_resolution - 1.0);\n    return rayInit(lookFrom, lowerLeftCorner + uv.x * horizontal + uv.y * vertical - lookFrom);\n}\n"},57:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.PreviewSection=void 0;const i=n(697);t.PreviewSection=class{constructor(){this.renderer=new i.Renderer(320,240),this.targetYSlider=$('<input type="range" min="0.6" max="3" step="0.00001" value="0.9">').on("input",(()=>this.preview())),this.cameraZSlider=$('<input type="range" min="-10000" max="10000" step="0.00001" value="0">').on("input",(()=>this.preview())),this.cameraXSlider=$('<input type="range" min="-10000" max="10000" step="0.00001" value="0">').on("input",(()=>this.preview())),this.minYSlider=$('<input type="range" min="100" max="400" step="0.00001" value="100">').on("input",(()=>this.preview())),this.alphaScaleSlider=$('<input type="range" min="0" max="0.05" step="0.00001" value="0.03">').on("input",(()=>this.preview())),this.thicknessSlider=$('<input type="range" min="10" max="700" step="0.000011" value="330">').on("input",(()=>this.preview())),this.fbmScaleSlider=$('<input type="range" min="0.00001" max="0.01" step="0.00001" value="0.0006">').on("input",(()=>this.preview())),this.fbmDepthSlider=$('<input type="range" min="0.1" max="1" step="0.00001" value="0.5">').on("input",(()=>this.preview())),this.fbmThresholdSlider=$('<input type="range" min="0.1" max="1" step="0.00001" value="1">').on("input",(()=>this.preview())),this.skyColorFaderSlider=$('<input type="range" min="0.0" max="1" step="0.00001" value="0">').on("input",(()=>this.preview())),this.element=$("<section>").append($("<h2>").text("【STEP.1】 各種設定を行ってください"),$('<div class="preview-container">').append($(this.renderer.webGlCanvas.canvas).on("click",(()=>{console.log(JSON.stringify(this.getRenderParams(0)))})),$('<div class="params">').append($("<div>").text("カメラ上向き："),this.targetYSlider,$("<div>").text("カメラ前後："),this.cameraZSlider,$("<div>").text("カメラ左右："),this.cameraXSlider,$("<div>").text("雲の高度："),this.minYSlider,$("<div>").text("雲の濃さ："),this.alphaScaleSlider,$("<div>").text("雲の厚み："),this.thicknessSlider,$("<div>").text("雲の細かさ："),this.fbmScaleSlider,$("<div>").text("雲の細部強調："),this.fbmDepthSlider,$("<div>").text("雲の量："),this.fbmThresholdSlider,$("<div>").text("背景の色味："),this.skyColorFaderSlider))),this.loadPreset('{"targetY":1.24175,"cameraZ":-19.88072,"cameraX":2067.59443,"cloudMinY":100,"cloudThickness":329.999999,"cloudAlphaScale":0.03,"fbmScale":0.0006,"fbmDepth":0.5,"fbmThreshold":0.62247,"skyColorFader":0,"cloudMaxSteps":40,"fbmMaxSteps":10,"fbmMinSteps":2}'),this.preview()}getRenderParams(e){let t=0,n=0,i=0;switch(e){case 0:t=40,n=10,i=2;break;default:case 1:t=100,n=10,i=2;break;case 2:t=300,n=12,i=6;break;case 3:t=500,n=20,i=10}return{targetY:parseFloat(this.targetYSlider.val()+""),cameraZ:parseFloat(this.cameraZSlider.val()+""),cameraX:parseFloat(this.cameraXSlider.val()+""),cloudMinY:parseFloat(this.minYSlider.val()+""),cloudThickness:parseFloat(this.thicknessSlider.val()+""),cloudAlphaScale:parseFloat(this.alphaScaleSlider.val()+""),fbmScale:parseFloat(this.fbmScaleSlider.val()+""),fbmDepth:parseFloat(this.fbmDepthSlider.val()+""),fbmThreshold:parseFloat(this.fbmThresholdSlider.val()+""),skyColorFader:parseFloat(this.skyColorFaderSlider.val()+""),cloudMaxSteps:t,fbmMaxSteps:n,fbmMinSteps:i}}preview(){this.renderer.render(this.getRenderParams(0))}loadPreset(e){const t=JSON.parse(e);this.targetYSlider.val(t.targetY),this.cameraZSlider.val(t.cameraZ),this.cameraXSlider.val(t.cameraX),this.minYSlider.val(t.cloudMinY),this.alphaScaleSlider.val(t.cloudAlphaScale),this.thicknessSlider.val(t.cloudThickness),this.fbmScaleSlider.val(t.fbmScale),this.fbmDepthSlider.val(t.fbmDepth),this.fbmThresholdSlider.val(t.fbmThreshold),this.skyColorFaderSlider.val(t.skyColorFader)}}},63:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.RenderSection=void 0;const i=n(697);t.RenderSection=class{constructor(e){this.renderer=new i.Renderer(1,1),this.widthInput=$('<input type="number" min="1" value="800">'),this.heightInput=$('<input type="number" min="1" value="600">'),this.resultDiv=$('<div class="render-result">'),this.qualitySelect=$("<select>").append($('<option value="0">').text("低"),$('<option value="1" selected>').text("中"),$('<option value="2">').text("高"),$('<option value="3">').text("最高")),this.element=$("<section>").append($("<h2>").text("【STEP.2】 問題無ければ[画像生成]ボタンを押してください"),$('<div class="render-contents">').append($('<div class="params">').append($("<div>").text("出力解像度："),$('<div class="resolution">').append(this.widthInput,$("<div>").text("×"),this.heightInput),$("<div>").text("品質："),this.qualitySelect),$("<button>").text("画像生成").on("click",(()=>e())),$("<ul>").append(["スマホでは品質や解像度を上げると正常に動作しない場合があります。なるべくハイスペックなPCでお試しください。","画像が生成されたら画像を右クリック（長押し）してコピーや保存を行ってください。"].map((e=>$("<li>").text(e)))),this.resultDiv))}render(e){const t=parseInt(this.qualitySelect.val()+""),n=e.getRenderParams(t),i=Math.max(Math.floor(parseInt(this.widthInput.val()+"")),1),o=Math.max(Math.floor(parseInt(this.heightInput.val()+"")),1);this.resultDiv.empty(),this.renderer.webGlCanvas.resize(i,o),this.renderer.render(n);const a=new Image;a.src=this.renderer.webGlCanvas.canvas.toDataURL("image/png"),this.resultDiv.append(a)}}},108:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.defines=void 0,t.defines="\nprecision highp float;\nprecision highp int;\n\nuniform vec2 u_resolution;\nuniform float u_targetY;\nuniform float u_cameraZ;\nuniform float u_cameraX;\nuniform float u_cloudMinY;\nuniform float u_cloudThickness;\nuniform float u_cloudAlphaScale;\nuniform float u_fbmScale;\nuniform float u_fbmDepth;\nuniform float u_fbmThreshold;\nuniform float u_skyColorFader;\nuniform float u_yOffset;\n\nuniform int u_cloudMaxSteps;\nuniform int u_fbmMaxSteps;\nuniform int u_fbmMinSteps;\n\nuniform int u_renderYOffset;\n\nconst float PI = 3.14159265359;\n"},136:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ray=void 0,t.ray="\nstruct Ray {\n    // レイの原点\n    vec3 origin;\n    // レイの方向（単位ベクトル）\n    vec3 direction;\n};\n\n// レイ初期化\nRay rayInit(vec3 origin, vec3 direction) {\n    return Ray(origin, normalize(direction));\n}\n\n// レイの進行度tにおける座標を取得\nvec3 rayAt(Ray ray, float t) {\n    return ray.origin + t * ray.direction;\n}\n"},157:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.cloud=void 0,t.cloud="\nvec3 cameraOrigin;\n\nfloat fbm(vec3 p) {\n    float res = 0.0;\n\n    // 近いところは回数を増やしたい\n    float dist = distance(cameraOrigin, p);\n    int steps = int(mix(float(u_fbmMaxSteps), float(u_fbmMinSteps), clamp(dist / 3000.0, 0.0, 1.0)));\n\n    for (int i = 0; i < 50; i++) {\n        if (i >= steps) {\n            break;\n        }\n    \n        float scale = u_fbmScale * pow(4.0, float(i));\n        float depth = pow(u_fbmDepth, float(i));\n        float noise = snoise(p * scale);\n        if (i == 0) {\n            noise -= (1.0 - u_fbmThreshold);\n        }\n        res += noise * depth;\n    }\n    return res;\n}\n\nfloat sampleCloudDensity(vec3 p) {\n    return fbm(p);\n}\n\n// Yが指定した値になるときのtを求めます。負の値なら存在しません。\nfloat calcHitAtY(float y, Ray ray) {\n    if (ray.direction.y == 0.0) { return -1.0; }\n    return (y - ray.origin.y) / ray.direction.y;\n}\n\nfloat saturate(float f) {\n   return clamp(f, 0.0, 1.0);\n}\n\n// レイマーチングで雲の色を算出します。\nvec4 getCloudColor(Ray ray) {\n    if (ray.direction.y < 0.0) {\n        ray.direction.y = -ray.direction.y;\n    }\n\n    // 透明度 1で完全透明、0で不透明\n    float transmittance = 1.0;\n    // 密度の累積\n    float accumulatedDensity = 0.0; \n\n    float tMin = calcHitAtY(u_cloudMinY, ray);\n    float tMax = calcHitAtY(u_cloudMinY + u_cloudThickness, ray);\n    if (tMin < 0.0 || tMax < 0.0) { return vec4(0.0); }\n    \n    float stepSize = (tMax - tMin) / float(u_cloudMaxSteps);\n\n\n    float t = tMin;\n    vec3 p = rayAt(ray, tMin);\n    vec3 pStep = ray.direction * stepSize;\n\n    for (int i = 0; i < 1000; i++) {\n        if (i >= u_cloudMaxSteps) {\n            break;\n        }\n\n        float density = sampleCloudDensity(p);\n        \n        // 密度が小さすぎる値は無視します。\n        if (density > 0.001) {\n            float alpha = saturate(density * stepSize * u_cloudAlphaScale);\n            accumulatedDensity += alpha * transmittance;\n            transmittance *= 1.0 - alpha;\n        }\n\n        // 不透明度になってきたら計算を終了します。\n        if (transmittance < 0.01) {\n            break;\n        }\n\n        p += pStep;\n    }\n\n    return vec4(vec3(1.0), accumulatedDensity);\n}\n"},308:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.buildFragmentShader=function(){return`${a.defines}\n${s.simplexNoise}\n${r.ray}\n${i.camera}\n${l.skybox}\n${o.cloud}\n\nvoid main() {\n    vec3 lookFrom = vec3(u_cameraX, 0.0, -u_cameraZ);\n    cameraOrigin = lookFrom;\n    vec3 lookAt = vec3(lookFrom.x, u_targetY, lookFrom.z - 1.0);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n    Ray ray = cameraGetRay(lookFrom, lookAt, vUp, 70.0);\n    \n    vec3 sky = getSkybox(ray);\n    vec4 cloud = getCloudColor(ray);\n    vec3 col = mix(sky, cloud.rgb, cloud.a);\n    gl_FragColor = vec4(col, 1.0);\n}\n`};const i=n(33),o=n(157),a=n(108),r=n(136),s=n(674),l=n(372)},372:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.skybox=void 0,t.skybox="\n\n\nvec3 getSkybox(Ray r) {\n    vec3 skyTopColors[2];\n    skyTopColors[0] = vec3(0.0, 35.0 / 255.0, 127.0 / 255.0);\n    skyTopColors[1] = vec3(0.0, 129.0 / 189.0, 223.0 / 255.0);\n\n    vec3 skyBottomColors[2];\n    skyBottomColors[0] = vec3(94.0 / 255.0, 192.0 / 255.0, 249.0 / 255.0), \n    skyBottomColors[1] = vec3(159.0 / 255.0, 210.0 / 255.0, 214.0 / 255.0);\n    vec3 landColor = vec3(0.0, 0.5, 1.0);\n\n    //int colorIdx = int(u_skyColorFader);\n    float alpha = clamp(u_skyColorFader, 0.0, 1.0);\n    vec3 bottomColor = mix(skyBottomColors[0], skyBottomColors[1], alpha);\n    vec3 topColor = mix(skyTopColors[0], skyTopColors[1], alpha);\n\n    // >= 0.0だと丸め誤差の差異がフレームごとに出る？\n    return r.direction.y > 0.0 ? mix(bottomColor, topColor, r.direction.y) : landColor;\n}\n"},674:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.simplexNoise=void 0,t.simplexNoise="\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n"},697:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Renderer=void 0;const i=n(308),o=n(929);t.Renderer=class{constructor(e,t){this.webGlCanvas=new o.WebGLCanvas(e,t,(0,i.buildFragmentShader)()),this.setupUniformLocations()}setupUniformLocations(){this.targetYUniformLocation=this.webGlCanvas.getUniformLocation("u_targetY"),this.cameraZUniformLocation=this.webGlCanvas.getUniformLocation("u_cameraZ"),this.cameraXUniformLocation=this.webGlCanvas.getUniformLocation("u_cameraX"),this.cloudMinYUniformLocation=this.webGlCanvas.getUniformLocation("u_cloudMinY"),this.cloudThicknessUniformLocation=this.webGlCanvas.getUniformLocation("u_cloudThickness"),this.cloudAlphaScaleUniformLocation=this.webGlCanvas.getUniformLocation("u_cloudAlphaScale"),this.fbmScaleUniformLocation=this.webGlCanvas.getUniformLocation("u_fbmScale"),this.fbmDepthUniformLocation=this.webGlCanvas.getUniformLocation("u_fbmDepth"),this.fbmThresholdUniformLocation=this.webGlCanvas.getUniformLocation("u_fbmThreshold"),this.skyColorFaderUniformLocation=this.webGlCanvas.getUniformLocation("u_skyColorFader"),this.cloudMaxStepsUniformLocation=this.webGlCanvas.getUniformLocation("u_cloudMaxSteps"),this.fbmMaxStepsUniformLocation=this.webGlCanvas.getUniformLocation("u_fbmMaxSteps"),this.fbmMinStepsUniformLocation=this.webGlCanvas.getUniformLocation("u_fbmMinSteps"),this.renderYOffsetUniformLocation=this.webGlCanvas.getUniformLocation("u_renderYOffset")}render(e,t=0){this.webGlCanvas.isContextLost&&(this.webGlCanvas.setupWebGL(),this.setupUniformLocations()),this.webGlCanvas.uniform1f(this.targetYUniformLocation,e.targetY),this.webGlCanvas.uniform1f(this.cameraZUniformLocation,e.cameraZ),this.webGlCanvas.uniform1f(this.cameraXUniformLocation,e.cameraX),this.webGlCanvas.uniform1f(this.cloudMinYUniformLocation,e.cloudMinY),this.webGlCanvas.uniform1f(this.cloudThicknessUniformLocation,e.cloudThickness),this.webGlCanvas.uniform1f(this.cloudAlphaScaleUniformLocation,e.cloudAlphaScale),this.webGlCanvas.uniform1f(this.fbmScaleUniformLocation,e.fbmScale),this.webGlCanvas.uniform1f(this.fbmDepthUniformLocation,e.fbmDepth),this.webGlCanvas.uniform1f(this.fbmThresholdUniformLocation,e.fbmThreshold),this.webGlCanvas.uniform1f(this.skyColorFaderUniformLocation,e.skyColorFader),this.webGlCanvas.uniform1i(this.cloudMaxStepsUniformLocation,e.cloudMaxSteps),this.webGlCanvas.uniform1i(this.fbmMaxStepsUniformLocation,e.fbmMaxSteps),this.webGlCanvas.uniform1i(this.fbmMinStepsUniformLocation,e.fbmMinSteps),this.webGlCanvas.uniform1i(this.renderYOffsetUniformLocation,t),this.webGlCanvas.render()}}},823:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ChangelogSection=void 0,t.ChangelogSection=class{constructor(){this.element=$("<section>").append($("<h2>").text("更新履歴"),$("<div>").append($("<ul>").append($("<li>").html("2025/04/06 Ver.1.0.4 WebGLのシェーダーで書き直した"),$("<li>").html('2025/03/29 <a href="./old/1.0.3/">Ver.1.0.3</a> 「雲の細かさ」「雲の細部強調」パラメータ追加'),$("<li>").html("2025/03/30 Ver.1.0.2 UIスマホ対応"),$("<li>").html("2025/03/29 Ver.1.0.1 雲生成部分にfBM（非整数ブラウン運動）を採用"),$("<li>").html('2025/03/29 <a href="./old/1.0/">Ver.1.0</a> 初期リリース'))))}}},929:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLCanvas=void 0,t.WebGLCanvas=class{constructor(e,t,n){this.fragmentShaderSource=n,this.canvas=$("<canvas>")[0],this.canvas.width=e,this.canvas.height=t;const i=this.canvas.getContext("webgl",{preserveDrawingBuffer:!0});if(!i)throw alert("WebGLの初期化に失敗"),"WebGLの初期化に失敗";this.gl=i,this.setupWebGL()}get isContextLost(){return this.gl.isContextLost()}setupWebGL(){const e=this.gl,t=this.createShader(e.VERTEX_SHADER,"\nattribute vec4 a_position;\nvoid main() {\n    gl_Position = a_position;\n}\n"),n=this.createShader(e.FRAGMENT_SHADER,this.fragmentShaderSource),i=e.createProgram();this.program=i,e.attachShader(i,t),e.attachShader(i,n),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS)||console.error("Program link error:",e.getProgramInfoLog(i)),e.useProgram(i);const o=new Float32Array([-1,-1,1,-1,-1,1,1,1]),a=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,a),e.bufferData(e.ARRAY_BUFFER,o,e.STATIC_DRAW);const r=e.getAttribLocation(i,"a_position");e.vertexAttribPointer(r,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(r),this.uResolutionLocation=e.getUniformLocation(i,"u_resolution"),e.uniform2f(this.uResolutionLocation,this.canvas.width,this.canvas.height)}getUniformLocation(e){return this.gl.getUniformLocation(this.program,e)}uniform1f(e,t){this.gl.uniform1f(e,t)}uniform1i(e,t){this.gl.uniform1i(e,t)}render(){const e=this.gl;e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT),e.drawArrays(e.TRIANGLE_STRIP,0,4)}resize(e,t){this.canvas.width=e,this.canvas.height=t,this.gl.uniform2f(this.uResolutionLocation,e,t),this.gl.viewport(0,0,e,t)}resizeForLineRenderer(e,t){this.canvas.width=e,this.canvas.height=1,this.gl.uniform2f(this.uResolutionLocation,e,t),this.gl.viewport(0,0,e,1)}createShader(e,t){const n=this.gl.createShader(e);if(!n)throw"shader can't created!";if(this.gl.shaderSource(n,t),this.gl.compileShader(n),!this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS))throw console.log(t),`Shader compile error: ${this.gl.getShaderInfoLog(n)}`;return n}}},948:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ReadmeSection=void 0,t.ReadmeSection=class{constructor(){this.element=$("<section>").append($("<h2>").text("【STEP.0】 お読みください"),$("<div>").append($("<ul>").append($("<li>").text("青空の画像を計算で生成します。"),$("<li>").text("生成された画像の著作権は利用者に帰属します。商用利用可能です（クレジット表記などは歓迎いたします）。"),$("<li>").html('現在のバージョンはWebGLを使用していますが、動作が不安定な場合は<a href="./old/1.0.3/">Ver.1.0.3をお試しください</a>。1.0.3はCPUによるレンダリングです。'),$("<li>").html('ソースコードはこちら：<a href="https://github.com/takabosoft/blue-sky-gen" target="_blank">https://github.com/takabosoft/blue-sky-gen</a>'))))}}}},t={};function n(i){var o=t[i];if(void 0!==o)return o.exports;var a=t[i]={exports:{}};return e[i](a,a.exports,n),a.exports}(()=>{const e=n(823),t=n(57),i=n(948),o=n(63);$((()=>new a));class a{constructor(){const n=new t.PreviewSection,a=new o.RenderSection((()=>a.render(n)));$(document.body).append($("<main>").append((new i.ReadmeSection).element,n.element,a.element,(new e.ChangelogSection).element),$("<footer>").html('青空ジェネレーター Copyright (C) 2025 <a href="https://takabosoft.com/" target="_blank">Takabo Soft</a>'))}}})()})();